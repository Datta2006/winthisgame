<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Pixel Prince - Fixed Jump</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            font-family: 'Courier New', monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            touch-action: none;
        }

        #gameContainer {
            position: relative;
            width: 800px;
            height: 600px;
            background: linear-gradient(to bottom, #87CEEB 0%, #98FB98 100%);
            border: 4px solid #333;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        #gameWorld {
            position: absolute;
            width: 2000px;
            height: 600px;
            transition: transform 0.1s ease-out;
        }

        .platform {
            position: absolute;
            background: #8B4513;
            border: 2px solid #A0522D;
            box-shadow: inset 0 2px 4px rgba(255,255,255,0.3);
        }

        .ground {
            background: #228B22;
            border: 2px solid #32CD32;
        }

        #player {
            position: absolute;
            width: 32px;
            height: 32px;
            background: #FF6B6B;
            border: 2px solid #FF4757;
            border-radius: 2px;
            z-index: 10;
            transition: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        #player::before {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            right: 2px;
            bottom: 2px;
            background: linear-gradient(45deg, #FF6B6B, #FF4757);
            border-radius: 1px;
        }

        #player::after {
            content: '‚ôï';
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            color: #FFD700;
            font-size: 16px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        .coin {
            position: absolute;
            width: 20px;
            height: 20px;
            background: #FFD700;
            border: 2px solid #FFA500;
            border-radius: 50%;
            animation: coinSpin 1s linear infinite;
            z-index: 5;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        .coin::before {
            content: '$';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #B8860B;
            font-weight: bold;
            font-size: 12px;
        }

        @keyframes coinSpin {
            0% { transform: rotateY(0deg) scale(1); }
            50% { transform: rotateY(180deg) scale(1.2); }
            100% { transform: rotateY(360deg) scale(1); }
        }

        .spike {
            position: absolute;
            width: 32px;
            height: 32px;
            background: #DC143C;
            border: 2px solid #B22222;
            clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
            z-index: 5;
        }

        .enemy {
            position: absolute;
            width: 28px;
            height: 28px;
            background: #8B008B;
            border: 2px solid #9400D3;
            border-radius: 2px;
            z-index: 5;
            animation: enemyBob 0.5s ease-in-out infinite alternate;
        }

        .enemy::before {
            content: 'üëæ';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 16px;
        }

        @keyframes enemyBob {
            0% { transform: translateY(0px); }
            100% { transform: translateY(-3px); }
        }

        .flag {
            position: absolute;
            width: 40px;
            height: 60px;
            background: #654321;
            border: 2px solid #8B4513;
            z-index: 5;
        }

        .flag::before {
            content: 'üèÅ';
            position: absolute;
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 24px;
            animation: flagWave 0.5s ease-in-out infinite alternate;
        }

        @keyframes flagWave {
            0% { transform: translateX(-50%) rotate(-5deg); }
            100% { transform: translateX(-50%) rotate(5deg); }
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 20;
            color: white;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        #health {
            margin-top: 10px;
        }

        .heart {
            color: #FF0000;
            font-size: 20px;
            margin-right: 5px;
            transition: all 0.3s ease;
        }

        #gameOver, #gameWin {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            z-index: 30;
            display: none;
            border: 3px solid #FFD700;
            width: 300px;
        }

        #gameWin {
            border-color: #00FF00;
        }

        .restart-btn {
            background: #FF6B6B;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 15px;
            font-family: 'Courier New', monospace;
            transition: all 0.2s ease;
        }

        .restart-btn:hover {
            background: #FF4757;
            transform: scale(1.05);
        }

        #instructions {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            font-size: 12px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            z-index: 20;
            background: rgba(0,0,0,0.5);
            padding: 5px 10px;
            border-radius: 5px;
        }

        .jumping {
            animation: jumpAnimation 0.3s ease-out;
        }

        @keyframes jumpAnimation {
            0% { transform: scaleY(1); }
            50% { transform: scaleY(1.2) scaleX(0.8); }
            100% { transform: scaleY(1); }
        }

        .cloud {
            position: absolute;
            background: white;
            border-radius: 50px;
            opacity: 0.8;
            animation: cloudFloat 30s linear infinite;
        }

        .cloud1 {
            width: 60px;
            height: 30px;
            top: 80px;
            left: -60px;
        }

        .cloud2 {
            width: 80px;
            height: 40px;
            top: 120px;
            left: -80px;
            animation-delay: -15s;
        }

        .cloud3 {
            width: 100px;
            height: 50px;
            top: 60px;
            left: -100px;
            animation-delay: -10s;
        }

        @keyframes cloudFloat {
            0% { transform: translateX(0); }
            100% { transform: translateX(2100px); }
        }

        .particle {
            position: absolute;
            background: #FFD700;
            border-radius: 50%;
            pointer-events: none;
            z-index: 15;
        }

        #mobileControls {
            display: none;
            position: absolute;
            bottom: 60px;
            width: 100%;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 25;
        }

        .mobile-btn {
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 24px;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        #jumpBtn {
            margin-left: auto;
            margin-right: 20px;
        }

        #pauseScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 40;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
        }

        #pauseScreen h2 {
            font-size: 36px;
            margin-bottom: 20px;
        }

        #pauseBtn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            z-index: 30;
            cursor: pointer;
        }

        .checkpoint {
            position: absolute;
            width: 30px;
            height: 40px;
            background: #4169E1;
            border: 2px solid #1E90FF;
            z-index: 5;
        }

        .checkpoint::before {
            content: '‚öë';
            position: absolute;
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 16px;
            color: #FFD700;
        }

        .checkpoint.active {
            background: #32CD32;
            border-color: #228B22;
        }

        .checkpoint.active::before {
            color: #FFFFFF;
        }

        #dashMeter {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 100px;
            height: 10px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            overflow: hidden;
            z-index: 20;
        }

        #dashFill {
            height: 100%;
            width: 100%;
            background: linear-gradient(to right, #FF4500, #FF8C00);
            transition: width 0.1s linear;
        }

        #dashLabel {
            position: absolute;
            bottom: 25px;
            right: 10px;
            color: white;
            font-size: 12px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }

        @media (max-width: 800px) {
            #gameContainer {
                width: 100vw;
                height: 100vh;
                border: none;
            }
            
            #mobileControls {
                display: flex;
            }
            
            #instructions {
                bottom: 130px;
                font-size: 11px;
                max-width: 90%;
            }
        }

        @keyframes dashTrail {
            0% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(0.5); }
        }

        @keyframes shake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            50% { transform: translateX(5px); }
            75% { transform: translateX(-5px); }
            100% { transform: translateX(0); }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="gameWorld">
            <!-- Background clouds -->
            <div class="cloud cloud1"></div>
            <div class="cloud cloud2"></div>
            <div class="cloud cloud3"></div>
            
            <!-- Player -->
            <div id="player"></div>
            
            <!-- Platforms -->
            <div class="platform ground" style="left: 0px; top: 550px; width: 400px; height: 50px;"></div>
            <div class="platform" style="left: 150px; top: 450px; width: 120px; height: 20px;"></div>
            <div class="platform" style="left: 350px; top: 350px; width: 120px; height: 20px;"></div>
            <div class="platform ground" style="left: 500px; top: 550px; width: 200px; height: 50px;"></div>
            <div class="platform" style="left: 600px; top: 400px; width: 120px; height: 20px;"></div>
            <div class="platform" style="left: 800px; top: 300px; width: 120px; height: 20px;"></div>
            <div class="platform ground" style="left: 950px; top: 550px; width: 300px; height: 50px;"></div>
            <div class="platform" style="left: 1100px; top: 450px; width: 120px; height: 20px;"></div>
            <div class="platform" style="left: 1300px; top: 350px; width: 120px; height: 20px;"></div>
            <div class="platform ground" style="left: 1450px; top: 550px; width: 150px; height: 50px;"></div>
            <div class="platform" style="left: 1650px; top: 450px; width: 120px; height: 20px;"></div>
            <div class="platform ground" style="left: 1800px; top: 550px; width: 200px; height: 50px;"></div>
            
            <!-- Coins -->
            <div class="coin" style="left: 180px; top: 520px;"></div>
            <div class="coin" style="left: 200px; top: 420px;"></div>
            <div class="coin" style="left: 400px; top: 320px;"></div>
            <div class="coin" style="left: 550px; top: 520px;"></div>
            <div class="coin" style="left: 650px; top: 370px;"></div>
            <div class="coin" style="left: 850px; top: 270px;"></div>
            <div class="coin" style="left: 1000px; top: 520px;"></div>
            <div class="coin" style="left: 1150px; top: 420px;"></div>
            <div class="coin" style="left: 1350px; top: 320px;"></div>
            <div class="coin" style="left: 1500px; top: 520px;"></div>
            <div class="coin" style="left: 1700px; top: 420px;"></div>
            <div class="coin" style="left: 1850px; top: 520px;"></div>
            
            <!-- Spikes -->
            <div class="spike" style="left: 320px; top: 515px;"></div>
            <div class="spike" style="left: 352px; top: 515px;"></div>
            <div class="spike" style="left: 750px; top: 515px;"></div>
            <div class="spike" style="left: 1250px; top: 515px;"></div>
            <div class="spike" style="left: 1282px; top: 515px;"></div>
            <div class="spike" style="left: 1700px; top: 515px;"></div>
            
            <!-- Enemies -->
            <div class="enemy" style="left: 500px; top: 520px;"></div>
            <div class="enemy" style="left: 1000px; top: 520px;"></div>
            <div class="enemy" style="left: 1600px; top: 520px;"></div>
            
            <!-- Checkpoints -->
            <div class="checkpoint" style="left: 750px; top: 500px;"></div>
            <div class="checkpoint" style="left: 1400px; top: 500px;"></div>
            
            <!-- Flag at the end -->
            <div class="flag" style="left: 1920px; top: 480px;"></div>
        </div>
        
        <div id="ui">
            <div>Score: <span id="score">0</span></div>
            <div id="health">
                <span class="heart">‚ô•</span>
                <span class="heart">‚ô•</span>
                <span class="heart">‚ô•</span>
            </div>
        </div>
        
        <div id="dashLabel">DASH</div>
        <div id="dashMeter">
            <div id="dashFill"></div>
        </div>
        
        <div id="instructions">
            Use WASD or Arrow Keys to move ‚Ä¢ SPACE or UP to jump ‚Ä¢ SHIFT to dash ‚Ä¢ Collect coins ‚Ä¢ Avoid spikes and enemies ‚Ä¢ Reach the flag!
        </div>
        
        <button id="pauseBtn">Pause</button>
        
        <div id="mobileControls">
            <div class="mobile-btn" id="leftBtn">‚Üê</div>
            <div class="mobile-btn" id="rightBtn">‚Üí</div>
            <div class="mobile-btn" id="jumpBtn">‚Üë</div>
        </div>
        
        <div id="gameOver">
            <h2>Game Over!</h2>
            <p>Final Score: <span id="finalScore">0</span></p>
            <button class="restart-btn" onclick="restartGame()">Play Again</button>
        </div>
        
        <div id="gameWin">
            <h2>üéâ You Win! üéâ</h2>
            <p>Congratulations, Prince!</p>
            <p>Final Score: <span id="winScore">0</span></p>
            <button class="restart-btn" onclick="restartGame()">Play Again</button>
        </div>
        
        <div id="pauseScreen">
            <h2>Game Paused</h2>
            <p>Score: <span id="pauseScore">0</span></p>
            <button class="restart-btn" onclick="resumeGame()">Resume</button>
            <button class="restart-btn" onclick="restartGame()" style="margin-top: 10px;">Restart</button>
        </div>
    </div>

    <script>
        const gameWorld = document.getElementById('gameWorld');
        const player = document.getElementById('player');
        const scoreElement = document.getElementById('score');
        const healthElement = document.getElementById('health');
        const gameOverScreen = document.getElementById('gameOver');
        const gameWinScreen = document.getElementById('gameWin');
        const pauseScreen = document.getElementById('pauseScreen');
        const pauseBtn = document.getElementById('pauseBtn');
        const pauseScore = document.getElementById('pauseScore');
        const dashFill = document.getElementById('dashFill');
        
        // Mobile controls
        const leftBtn = document.getElementById('leftBtn');
        const rightBtn = document.getElementById('rightBtn');
        const jumpBtn = document.getElementById('jumpBtn');
        
        let gameState = {
            playerX: 50,
            playerY: 500,
            velocityX: 0,
            velocityY: 0,
            onGround: false,
            health: 3,
            score: 0,
            gameRunning: true,
            cameraX: 0,
            invulnerable: false,
            enemies: [],
            checkpoints: [],
            dashCooldown: 0,
            dashMeter: 100,
            lastCheckpoint: { x: 50, y: 500 },
            isPaused: false,
            coinsCollected: 0,
            timeStarted: Date.now(),
            mobileLeft: false,
            mobileRight: false,
            mobileJump: false,
            // NEW: Jump buffer variables
            jumpRequested: false,
            coyoteTime: 0,
            jumpBuffer: 0
        };
        
        const GRAVITY = 0.5;
        const JUMP_FORCE = -12;
        const MOVE_SPEED = 5;
        const DASH_SPEED = 12;
        const DASH_DURATION = 15;
        const WORLD_WIDTH = 2000;
        const CAMERA_OFFSET = 400;
        // NEW: Jump buffer constants
        const COYOTE_TIME_MAX = 10; // frames
        const JUMP_BUFFER_MAX = 8; // frames
        
        // Initialize enemies
        const enemyElements = document.querySelectorAll('.enemy');
        enemyElements.forEach((enemy, index) => {
            gameState.enemies.push({
                element: enemy,
                x: parseInt(enemy.style.left),
                y: parseInt(enemy.style.top),
                direction: index % 2 === 0 ? 1 : -1,
                speed: 1.5,
                patrolDistance: 120,
                originalX: parseInt(enemy.style.left)
            });
        });
        
        // Initialize checkpoints
        const checkpointElements = document.querySelectorAll('.checkpoint');
        checkpointElements.forEach((checkpoint, index) => {
            gameState.checkpoints.push({
                element: checkpoint,
                x: parseInt(checkpoint.style.left),
                y: parseInt(checkpoint.style.top),
                active: false
            });
        });
        
        // Input handling
        const keys = {};
        
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                togglePause();
                return;
            }
            
            keys[e.key.toLowerCase()] = true;
            
            // Jump - only set flag now, actual jump handled in update
            if ((e.key === ' ' || e.key === 'ArrowUp' || e.key === 'w') && gameState.gameRunning && !gameState.isPaused) {
                gameState.jumpRequested = true;
                gameState.jumpBuffer = JUMP_BUFFER_MAX;
            }
            
            // Dash
            if (e.key === 'Shift' && gameState.dashMeter >= 30 && gameState.gameRunning && !gameState.isPaused) {
                dash();
            }
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });
        
        // Mobile controls
        leftBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            gameState.mobileLeft = true;
        });
        
        leftBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            gameState.mobileLeft = false;
        });
        
        rightBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            gameState.mobileRight = true;
        });
        
        rightBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            gameState.mobileRight = false;
        });
        
        jumpBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (gameState.gameRunning && !gameState.isPaused) {
                gameState.jumpRequested = true;
                gameState.jumpBuffer = JUMP_BUFFER_MAX;
            }
            gameState.mobileJump = true;
        });
        
        jumpBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            gameState.mobileJump = false;
        });
        
        // Pause button
        pauseBtn.addEventListener('click', togglePause);
        
        function jump() {
            gameState.velocityY = JUMP_FORCE;
            gameState.onGround = false;
            player.classList.add('jumping');
            setTimeout(() => player.classList.remove('jumping'), 300);
            
            // Jump particles
            createParticles(gameState.playerX + 16, gameState.playerY + 32, '#FFD700', 5);
            
            // Reset jump flags
            gameState.jumpRequested = false;
            gameState.coyoteTime = 0;
            gameState.jumpBuffer = 0;
        }
        
        function dash() {
            gameState.dashCooldown = DASH_DURATION;
            gameState.dashMeter -= 30;
            updateDashMeter();
            
            // Dash particles
            const dashColor = '#FF8C00';
            for (let i = 0; i < 10; i++) {
                setTimeout(() => {
                    createParticles(
                        gameState.playerX + 16, 
                        gameState.playerY + 16, 
                        dashColor, 
                        3
                    );
                }, i * 30);
            }
        }
        
        function togglePause() {
            gameState.isPaused = !gameState.isPaused;
            if (gameState.isPaused) {
                pauseScreen.style.display = 'flex';
                pauseScore.textContent = gameState.score;
            } else {
                pauseScreen.style.display = 'none';
            }
        }
        
        function resumeGame() {
            gameState.isPaused = false;
            pauseScreen.style.display = 'none';
        }
        
        function updatePlayer() {
            if (!gameState.gameRunning || gameState.isPaused) return;
            
            // Handle input
            if ((keys['a'] || keys['arrowleft'] || gameState.mobileLeft) && !(keys['d'] || keys['arrowright'] || gameState.mobileRight)) {
                gameState.velocityX = -MOVE_SPEED;
            } else if ((keys['d'] || keys['arrowright'] || gameState.mobileRight) && !(keys['a'] || keys['arrowleft'] || gameState.mobileLeft)) {
                gameState.velocityX = MOVE_SPEED;
            } else {
                gameState.velocityX *= 0.7; // Friction
            }
            
            // Handle dash
            if (gameState.dashCooldown > 0) {
                gameState.dashCooldown--;
                gameState.velocityX = gameState.velocityX > 0 ? DASH_SPEED : -DASH_SPEED;
            }
            
            // Recharge dash meter
            if (gameState.dashMeter < 100 && gameState.dashCooldown === 0) {
                gameState.dashMeter += 0.5;
                updateDashMeter();
            }
            
            // Apply gravity
            if (!gameState.onGround) {
                gameState.velocityY += GRAVITY;
            }
            
            // Update position
            gameState.playerX += gameState.velocityX;
            gameState.playerY += gameState.velocityY;
            
            // Boundary checks
            if (gameState.playerX < 0) gameState.playerX = 0;
            if (gameState.playerX > WORLD_WIDTH - 32) gameState.playerX = WORLD_WIDTH - 32;
            
            // Platform collision detection
            checkPlatformCollisions();
            
            // Ground collision (bottom boundary)
            if (gameState.playerY > 568) {
                gameState.playerY = 568;
                gameState.velocityY = 0;
                gameState.onGround = true;
            }
            
            // NEW: Coyote time - allow jumping shortly after leaving a platform
            if (gameState.onGround) {
                gameState.coyoteTime = COYOTE_TIME_MAX;
            } else {
                if (gameState.coyoteTime > 0) {
                    gameState.coyoteTime--;
                }
            }
            
            // NEW: Handle jump buffer
            if (gameState.jumpRequested && gameState.jumpBuffer > 0) {
                gameState.jumpBuffer--;
                
                // Check if we can jump (either on ground or in coyote time)
                if (gameState.onGround || gameState.coyoteTime > 0) {
                    jump();
                }
            } else if (gameState.jumpBuffer > 0) {
                gameState.jumpBuffer--;
            }
            
            // Update player position
            player.style.left = gameState.playerX + 'px';
            player.style.top = gameState.playerY + 'px';
            
            // Update camera
            updateCamera();
        }
        
        function checkPlatformCollisions() {
            const platforms = document.querySelectorAll('.platform');
            gameState.onGround = false;
            
            platforms.forEach(platform => {
                const platRect = {
                    x: parseInt(platform.style.left),
                    y: parseInt(platform.style.top),
                    width: parseInt(platform.style.width),
                    height: parseInt(platform.style.height)
                };
                
                const playerRect = {
                    x: gameState.playerX,
                    y: gameState.playerY,
                    width: 32,
                    height: 32
                };
                
                // Check collision
                if (playerRect.x < platRect.x + platRect.width &&
                    playerRect.x + playerRect.width > platRect.x &&
                    playerRect.y < platRect.y + platRect.height &&
                    playerRect.y + playerRect.height > platRect.y) {
                    
                    // Landing on top of platform
                    if (gameState.velocityY > 0 && 
                        playerRect.y + playerRect.height - gameState.velocityY <= platRect.y) {
                        gameState.playerY = platRect.y - 32;
                        gameState.velocityY = 0;
                        gameState.onGround = true;
                        
                        // Landing particles
                        if (Math.abs(gameState.velocityY) > 5) {
                            createParticles(
                                gameState.playerX + 16, 
                                gameState.playerY + 32, 
                                '#FFFFFF', 
                                8
                            );
                        }
                    }
                    // Hitting platform from below
                    else if (gameState.velocityY < 0 && 
                             playerRect.y > platRect.y + platRect.height - 10) {
                        gameState.playerY = platRect.y + platRect.height;
                        gameState.velocityY = 0;
                    }
                    // Side collisions
                    else if (gameState.velocityX > 0 && 
                             playerRect.x + playerRect.width - gameState.velocityX <= platRect.x) {
                        gameState.playerX = platRect.x - 32;
                        gameState.velocityX = 0;
                    }
                    else if (gameState.velocityX < 0 && 
                             playerRect.x >= platRect.x + platRect.width) {
                        gameState.playerX = platRect.x + platRect.width;
                        gameState.velocityX = 0;
                    }
                }
            });
        }
        
        function updateCamera() {
            // Follow player with offset
            let targetCameraX = gameState.playerX - CAMERA_OFFSET;
            
            // Clamp camera to world boundaries
            targetCameraX = Math.max(0, Math.min(targetCameraX, WORLD_WIDTH - 800));
            
            // Smooth camera movement
            gameState.cameraX += (targetCameraX - gameState.cameraX) * 0.1;
            
            gameWorld.style.transform = `translateX(${-gameState.cameraX}px)`;
        }
        
        function checkCollectibles() {
            const coins = document.querySelectorAll('.coin:not(.collected)');
            
            coins.forEach(coin => {
                const coinRect = {
                    x: parseInt(coin.style.left),
                    y: parseInt(coin.style.top),
                    width: 20,
                    height: 20
                };
                
                if (gameState.playerX < coinRect.x + coinRect.width &&
                    gameState.playerX + 32 > coinRect.x &&
                    gameState.playerY < coinRect.y + coinRect.height &&
                    gameState.playerY + 32 > coinRect.y) {
                    
                    // Mark coin as collected
                    coin.classList.add('collected');
                    
                    // Collect coin
                    gameState.score += 100;
                    gameState.coinsCollected++;
                    scoreElement.textContent = gameState.score;
                    
                    // Coin collection animation
                    const scorePopup = document.createElement('div');
                    scorePopup.textContent = '+100';
                    scorePopup.style.position = 'absolute';
                    scorePopup.style.left = (coinRect.x - gameState.cameraX) + 'px';
                    scorePopup.style.top = coinRect.y + 'px';
                    scorePopup.style.color = '#FFD700';
                    scorePopup.style.fontSize = '16px';
                    scorePopup.style.fontWeight = 'bold';
                    scorePopup.style.zIndex = '25';
                    scorePopup.style.pointerEvents = 'none';
                    scorePopup.style.animation = 'fadeUpAndOut 1s ease-out forwards';
                    
                    document.getElementById('gameContainer').appendChild(scorePopup);
                    
                    // Coin collection particles
                    createParticles(
                        coinRect.x + 10, 
                        coinRect.y + 10, 
                        '#FFD700', 
                        10
                    );
                    
                    setTimeout(() => {
                        coin.remove();
                        scorePopup.remove();
                    }, 1000);
                }
            });
        }
        
        function checkCheckpoints() {
            gameState.checkpoints.forEach(checkpoint => {
                const checkpointRect = {
                    x: checkpoint.x,
                    y: checkpoint.y,
                    width: 30,
                    height: 40
                };
                
                if (gameState.playerX < checkpointRect.x + checkpointRect.width &&
                    gameState.playerX + 32 > checkpointRect.x &&
                    gameState.playerY < checkpointRect.y + checkpointRect.height &&
                    gameState.playerY + 32 > checkpointRect.y && 
                    !checkpoint.active) {
                    
                    // Activate checkpoint
                    checkpoint.active = true;
                    checkpoint.element.classList.add('active');
                    gameState.lastCheckpoint = { x: checkpoint.x, y: checkpoint.y - 50 };
                    gameState.score += 200;
                    scoreElement.textContent = gameState.score;
                    
                    // Checkpoint activation effect
                    createParticles(
                        checkpointRect.x + 15, 
                        checkpointRect.y + 20, 
                        '#00FF00', 
                        15
                    );
                    
                    // Show checkpoint message
                    const checkpointPopup = document.createElement('div');
                    checkpointPopup.textContent = 'Checkpoint!';
                    checkpointPopup.style.position = 'absolute';
                    checkpointPopup.style.left = (checkpointRect.x - gameState.cameraX + 15) + 'px';
                    checkpointPopup.style.top = (checkpointRect.y - 30) + 'px';
                    checkpointPopup.style.color = '#00FF00';
                    checkpointPopup.style.fontSize = '16px';
                    checkpointPopup.style.fontWeight = 'bold';
                    checkpointPopup.style.zIndex = '25';
                    checkpointPopup.style.pointerEvents = 'none';
                    checkpointPopup.style.animation = 'fadeUpAndOut 1.5s ease-out forwards';
                    
                    document.getElementById('gameContainer').appendChild(checkpointPopup);
                    setTimeout(() => checkpointPopup.remove(), 1500);
                }
            });
        }
        
        function checkHazards() {
            if (gameState.invulnerable || gameState.dashCooldown > 0) return;
            
            const spikes = document.querySelectorAll('.spike');
            const enemies = document.querySelectorAll('.enemy:not(.defeated)');
            
            // Check spike collisions
            spikes.forEach(spike => {
                const spikeRect = {
                    x: parseInt(spike.style.left),
                    y: parseInt(spike.style.top),
                    width: 32,
                    height: 32
                };
                
                if (gameState.playerX < spikeRect.x + spikeRect.width &&
                    gameState.playerX + 32 > spikeRect.x &&
                    gameState.playerY < spikeRect.y + spikeRect.height &&
                    gameState.playerY + 32 > spikeRect.y) {
                    
                    takeDamage();
                }
            });
            
            // Check enemy collisions
            enemies.forEach(enemy => {
                const enemyRect = {
                    x: parseInt(enemy.style.left),
                    y: parseInt(enemy.style.top),
                    width: 28,
                    height: 28
                };
                
                if (gameState.playerX < enemyRect.x + enemyRect.width &&
                    gameState.playerX + 32 > enemyRect.x &&
                    gameState.playerY < enemyRect.y + enemyRect.height &&
                    gameState.playerY + 32 > enemyRect.y) {
                    
                    // Check if player is jumping on enemy
                    if (gameState.velocityY > 0 && 
                        gameState.playerY + 32 - gameState.velocityY <= enemyRect.y) {
                        // Bounce off enemy
                        gameState.velocityY = JUMP_FORCE * 0.8;
                        gameState.onGround = false;
                        
                        // Mark enemy as defeated
                        enemy.classList.add('defeated');
                        
                        // Enemy death
                        gameState.score += 200;
                        scoreElement.textContent = gameState.score;
                        
                        // Enemy death particles
                        createParticles(
                            enemyRect.x + 14, 
                            enemyRect.y + 14, 
                            '#8B008B', 
                            15
                        );
                        
                        // Remove enemy after a delay
                        setTimeout(() => enemy.remove(), 300);
                    } else {
                        takeDamage();
                    }
                }
            });
        }
        
        function checkWinCondition() {
            const flag = document.querySelector('.flag');
            const flagRect = {
                x: parseInt(flag.style.left),
                y: parseInt(flag.style.top),
                width: 40,
                height: 60
            };
            
            if (gameState.playerX < flagRect.x + flagRect.width &&
                gameState.playerX + 32 > flagRect.x &&
                gameState.playerY < flagRect.y + flagRect.height &&
                gameState.playerY + 32 > flagRect.y) {
                
                // Calculate time bonus
                const timeElapsed = (Date.now() - gameState.timeStarted) / 1000;
                const timeBonus = Math.max(0, 5000 - Math.floor(timeElapsed * 10));
                gameState.score += timeBonus;
                
                // Win the game
                gameState.gameRunning = false;
                document.getElementById('winScore').textContent = gameState.score;
                gameWinScreen.style.display = 'block';
                
                // Win celebration particles
                for (let i = 0; i < 50; i++) {
                    setTimeout(() => {
                        createParticles(
                            flagRect.x + 20, 
                            flagRect.y + 30, 
                            ['#FFD700', '#FF0000', '#00FF00', '#0000FF'][Math.floor(Math.random() * 4)], 
                            3
                        );
                    }, i * 100);
                }
            }
        }
        
        function takeDamage() {
            if (gameState.invulnerable) return;
            
            gameState.health--;
            updateHealthDisplay();
            
            // Make player invulnerable briefly
            gameState.invulnerable = true;
            player.style.opacity = '0.5';
            
            // Knockback effect
            gameState.velocityY = -8;
            gameState.velocityX = (gameState.playerX < CAMERA_OFFSET + 400) ? 5 : -5;
            
            // Damage shake effect
            gameWorld.style.animation = 'shake 0.3s';
            setTimeout(() => gameWorld.style.animation = '', 300);
            
            // Damage particles
            createParticles(
                gameState.playerX + 16, 
                gameState.playerY + 16, 
                '#FF0000', 
                10
            );
            
            setTimeout(() => {
                player.style.opacity = '1';
                gameState.invulnerable = false;
            }, 1500);
            
            // Check if game over
            if (gameState.health <= 0) {
                gameOver();
            }
        }
        
        function updateHealthDisplay() {
            const hearts = healthElement.querySelectorAll('.heart');
            hearts.forEach((heart, index) => {
                if (index < gameState.health) {
                    heart.style.opacity = '1';
                    heart.style.transform = 'scale(1)';
                } else {
                    heart.style.opacity = '0.3';
                    heart.style.transform = 'scale(0.8)';
                }
            });
        }
        
        function updateDashMeter() {
            dashFill.style.width = `${gameState.dashMeter}%`;
        }
        
        function updateEnemies() {
            gameState.enemies.forEach(enemy => {
                if (enemy.element.classList.contains('defeated')) return;
                
                // Move enemy back and forth
                enemy.x += enemy.direction * enemy.speed;
                
                // Check patrol boundaries
                if (Math.abs(enemy.x - enemy.originalX) > enemy.patrolDistance) {
                    enemy.direction *= -1;
                }
                
                // Update enemy position
                enemy.element.style.left = enemy.x + 'px';
            });
        }
        
        function createParticles(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                const particle = document.createElement('div');
                particle.classList.add('particle');
                particle.style.left = x + 'px';
                particle.style.top = y + 'px';
                particle.style.backgroundColor = color;
                particle.style.width = `${Math.random() * 6 + 4}px`;
                particle.style.height = particle.style.width;
                
                // Random direction and speed
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 3 + 1;
                const duration = Math.random() * 1000 + 500;
                
                particle.style.transform = `translate(${Math.cos(angle) * 10}px, ${Math.sin(angle) * 10}px)`;
                particle.style.opacity = '1';
                
                document.getElementById('gameWorld').appendChild(particle);
                
                // Animate particle
                const animation = particle.animate([
                    { 
                        transform: `translate(0, 0)`, 
                        opacity: 1 
                    },
                    { 
                        transform: `translate(${Math.cos(angle) * speed * 50}px, ${Math.sin(angle) * speed * 50}px)`, 
                        opacity: 0 
                    }
                ], {
                    duration: duration,
                    easing: 'cubic-bezier(0.4, 0, 0.2, 1)'
                });
                
                animation.onfinish = () => particle.remove();
            }
        }
        
        function gameOver() {
            gameState.gameRunning = false;
            document.getElementById('finalScore').textContent = gameState.score;
            gameOverScreen.style.display = 'block';
            
            // Game over particles
            createParticles(
                gameState.playerX + 16, 
                gameState.playerY + 16, 
                '#FF0000', 
                20
            );
        }
        
        function restartGame() {
            // Reset game state
            gameState = {
                playerX: gameState.lastCheckpoint.x,
                playerY: gameState.lastCheckpoint.y,
                velocityX: 0,
                velocityY: 0,
                onGround: false,
                health: 3,
                score: 0,
                gameRunning: true,
                cameraX: 0,
                invulnerable: false,
                enemies: [],
                checkpoints: [],
                dashCooldown: 0,
                dashMeter: 100,
                lastCheckpoint: { x: 50, y: 500 },
                isPaused: false,
                coinsCollected: 0,
                timeStarted: Date.now(),
                mobileLeft: false,
                mobileRight: false,
                mobileJump: false,
                // NEW: Jump buffer variables
                jumpRequested: false,
                coyoteTime: 0,
                jumpBuffer: 0
            };
            
            // Reset UI
            scoreElement.textContent = '0';
            updateHealthDisplay();
            updateDashMeter();
            gameOverScreen.style.display = 'none';
            gameWinScreen.style.display = 'none';
            pauseScreen.style.display = 'none';
            
            // Reset player position
            player.style.left = gameState.playerX + 'px';
            player.style.top = gameState.playerY + 'px';
            player.style.opacity = '1';
            
            // Reset camera
            gameWorld.style.transform = 'translateX(0)';
            gameWorld.style.animation = '';
            
            // Reset enemies
            document.querySelectorAll('.enemy').forEach(enemy => enemy.classList.remove('defeated'));
            
            // Reset checkpoints
            document.querySelectorAll('.checkpoint').forEach(checkpoint => {
                checkpoint.classList.remove('active');
            });
            
            // Reset coins
            document.querySelectorAll('.coin').forEach(coin => {
                coin.classList.remove('collected');
                coin.style.display = 'block';
            });
            
            // Reinitialize enemies and checkpoints
            const enemyElements = document.querySelectorAll('.enemy');
            enemyElements.forEach((enemy, index) => {
                gameState.enemies.push({
                    element: enemy,
                    x: parseInt(enemy.style.left),
                    y: parseInt(enemy.style.top),
                    direction: index % 2 === 0 ? 1 : -1,
                    speed: 1.5,
                    patrolDistance: 120,
                    originalX: parseInt(enemy.style.left)
                });
            });
            
            const checkpointElements = document.querySelectorAll('.checkpoint');
            checkpointElements.forEach((checkpoint, index) => {
                gameState.checkpoints.push({
                    element: checkpoint,
                    x: parseInt(checkpoint.style.left),
                    y: parseInt(checkpoint.style.top),
                    active: false
                });
            });
        }
        
        // Game loop
        function gameLoop() {
            if (!gameState.isPaused) {
                updatePlayer();
                updateEnemies();
                checkCollectibles();
                checkCheckpoints();
                checkHazards();
                checkWinCondition();
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        // Start the game
        gameLoop();
        
        // Add fadeUpAndOut animation to styles
        const style = document.createElement('style');
        style.textContent = `
            @keyframes fadeUpAndOut {
                0% { transform: translateY(0); opacity: 1; }
                100% { transform: translateY(-50px); opacity: 0; }
            }
        `;
        document.head.appendChild(style);
    </script>
</body>
</html>
